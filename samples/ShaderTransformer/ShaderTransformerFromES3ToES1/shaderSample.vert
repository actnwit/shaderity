{
  "code": "#version 300 es\n\n#define RN_IS_MORPHING\n\nprecision highp int;\nprecision highp float;\nprecision highp sampler2D;\nprecision highp samplerCube;\nprecision highp sampler3D;\nprecision highp sampler2DArray;\nprecision highp isampler2D;\nprecision highp isamplerCube;\nprecision highp isampler3D;\nprecision highp isampler2DArray;\nprecision highp usampler2D;\nprecision highp usamplerCube;\nprecision highp usampler3D;\nprecision highp usampler2DArray;\nprecision highp sampler2DShadow;\nprecision highp samplerCubeShadow;\nprecision highp sampler2DArrayShadow;\n\nconst int widthOfDataTexture = int(4096);\nconst int heightOfDataTexture = int(4096);\n\nin vec3 a_position;\nin vec3 a_color;\nin vec3 a_normal;\nin float a_instanceID;\nin vec2 a_texcoord_0;\nin vec2 a_texcoord_1;\nin vec4 a_joint;\nin vec4 a_weight;\nin vec4 a_baryCentricCoord;\nin vec4 a_tangent;\n\nout vec3 v_color;\nout vec3 v_normal_inWorld;\nout vec4 v_position_inWorld;\nout vec2 v_texcoord_0;\nout vec2 v_texcoord_1;\nout vec3 v_baryCentricCoord;\nout vec3 v_tangent_inWorld;\nout vec3 v_binormal_inWorld;\n\nuniform float u_materialSID;\nuniform float u_currentComponentSIDs[13];\nuniform mat4 u_viewMatrix;\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_worldMatrix;\nuniform mat3 u_normalMatrix;\nuniform int u_morphTargetNumber;\nuniform float u_morphWeights[40];\nuniform int u_dataTextureMorphOffsetPosition[40];\nuniform sampler2D u_dataTexture;\n\nfloat get_currentComponentSIDs(float instanceId, int index) {\n  float val;\n  for (int i = 0; i<13; i++) {\n    if (i == index) {\n      val = u_currentComponentSIDs[i];\n      break;\n    }\n  }\n  return val;\n}\nmat4 get_viewMatrix(float instanceId, int index) {\n  return u_viewMatrix;\n}\nmat4 get_projectionMatrix(float instanceId, int index) {\n  return u_projectionMatrix;\n}\nmat4 get_worldMatrix(highp float instanceId) {\n  return u_worldMatrix;\n}\nmat3 get_normalMatrix(const float instanceId) {\n  return u_normalMatrix;\n}\n#ifdef RN_IS_MORPHING\nhighp vec4 fetchElement(highp sampler2D tex, int vec4_idx, int texWidth, int texHeight) {\n  // This idea from https://qiita.com/YVT/items/c695ab4b3cf7faa93885\n  highp vec2 invSize = vec2(1.0 / float(texWidth), 1.0 / float(texHeight));\n  highp float t = (float(vec4_idx) + 0.5) * invSize.x;\n  highp float x = fract(t);\n  highp float y = (floor(t) + 0.5) * invSize.y;\n  return texture( tex, vec2(x, y));\n}\n#endif\n#ifdef RN_IS_MORPHING\nvec3 get_position(float vertexId, vec3 basePosition) {\n  vec3 position = basePosition;\n  int scalar_idx = 3 * int(vertexId);\n  #ifdef GLSL_ES3\n    int posIn4bytes = scalar_idx % 4;\n  #else\n    int posIn4bytes = int(mod(float(scalar_idx), 4.0));\n  #endif\n  for (int i = 0; i < 41; i++) {\n    int basePosIn16bytes = u_dataTextureMorphOffsetPosition[i] + (scalar_idx - posIn4bytes)/4;\n    vec3 addPos = vec3(0.0);\n    if (posIn4bytes == 0) {\n      vec4 val = fetchElement(u_dataTexture, basePosIn16bytes, widthOfDataTexture, heightOfDataTexture);\n      addPos = val.xyz;\n    }\n    else if (posIn4bytes == 1) {\n      vec4 val0 = fetchElement(u_dataTexture, basePosIn16bytes, widthOfDataTexture, heightOfDataTexture);\n      addPos = vec3(val0.yzw);\n    }\n    else if (posIn4bytes == 2) {\n      vec4 val0 = fetchElement(u_dataTexture, basePosIn16bytes, widthOfDataTexture, heightOfDataTexture);\n      vec4 val1 = fetchElement(u_dataTexture, basePosIn16bytes+1, widthOfDataTexture, heightOfDataTexture);\n      addPos = vec3(val0.zw, val1.x);\n    }\n    else if (posIn4bytes == 3) {\n      vec4 val0 = fetchElement(u_dataTexture, basePosIn16bytes, widthOfDataTexture, heightOfDataTexture);\n      vec4 val1 = fetchElement(u_dataTexture, basePosIn16bytes+1, widthOfDataTexture, heightOfDataTexture);\n      addPos = vec3(val0.w, val1.xy);\n    }\n    position += addPos * u_morphWeights[i];\n    if (i == u_morphTargetNumber-1) {\n      break;\n    }\n  }\n  return position;\n}\n#endif\nvoid processGeometryWithMorphing(\n  const in highp mat4 worldMatrix,\n  in mat3 inNormalMatrix,\n  out highp mat3 outNormalMatrix,\n  in vec3 inPosition_inLocal,\n  out vec4 outPosition_inWorld,\n  in vec3 inNormal_inLocal,\n  out vec3 outNormal_inWorld\n) {\n  vec3 position_inLocal = inPosition_inLocal;\n\n  #ifdef RN_IS_MORPHING\n    if (u_morphTargetNumber != 0) {\n      float vertexIdx = a_baryCentricCoord.w;\n      position_inLocal = get_position(vertexIdx, inPosition_inLocal);\n    }\n  #endif\n\n  outNormalMatrix = inNormalMatrix;\n  outPosition_inWorld = worldMatrix * vec4(position_inLocal, 1.0);\n  outNormal_inWorld = normalize(inNormalMatrix * inNormal_inLocal);\n}\n\nvoid main() {\n  float materialSID = u_materialSID;\n  float cameraSID = u_currentComponentSIDs[7];\n\n  mat4 worldMatrix = get_worldMatrix(a_instanceID);\n  mat4 viewMatrix = get_viewMatrix(cameraSID, 0);\n  mat4 projectionMatrix = get_projectionMatrix(cameraSID, 0);\n  mat3 normalMatrix = get_normalMatrix(a_instanceID);\n  processGeometryWithMorphing(\n    worldMatrix,\n    normalMatrix,\n    normalMatrix,\n    a_position,\n    v_position_inWorld,\n    a_normal,\n    v_normal_inWorld\n  );\n\n  gl_Position = projectionMatrix * viewMatrix * v_position_inWorld;\n\n  v_color = a_color;\n  v_texcoord_0 = a_texcoord_0;\n  v_texcoord_1 = a_texcoord_1;\n  v_baryCentricCoord = a_baryCentricCoord.xyz;\n\n  #ifdef RN_USE_TANGENT_ATTRIBUTE\n    v_tangent_inWorld = normalMatrix * a_tangent.xyz;\n    v_binormal_inWorld = cross(v_tangent_inWorld, v_normal_inWorld) * a_tangent.w;\n  #endif\n}\n",
  "shaderStage": "vertex",
  "isFragmentShader": false
}